\chapter{Approach}\label{chapter:approach}
In this chapter the changes to the existing VIBES framework are presented one by one. First the reasons for each improvement are described. Then the prerequisites for every change and the design and architecture are shown. Finally the implementation is explained. The implementation is split into frontend and backend. Since the frontend is only displaying the information from the backend the focus is on the backend, where the changes to the actual behaviour of the simlation are done. The frontend, the console output and the log file show the results of the backend and can therefore be used for the evaluation.

\section{Bitcoin-like Blockchain Simulation}
Extending the previous \textit{Generic Simulation} to \textit{Bitcoin-like Blockchain Simulation} made lots of changes necessary, especially in the frontend. More abstract ways to implement different strategies in the backend in Scala were researched. The backend differentiates between the currently only two strategies mainly with If-clauses. This seemed to be the best option, which avoids creating unnecessary complexity. It was also recommended by the author of VIBES. Bloated methods due to having multiple strategies in one method can be avoided by outsourcing strategy-specific parts to their own method(s).

\section{Time-outs and Configuration}
Previously the frontend could only display the information from the backend, if the simulation results were sent within 60 seconds. After checking the existing time-outs in the project and researching the default time-outs of the used frameworks, the problem was found in the akka.http.server.idle-timeout default setting. This default setting of 60 seconds was changed in \textit{\textbackslash vibes\textbackslash server\textbackslash src\textbackslash main\textbackslash resources\textbackslash application.conf} to infinite.

\begin{minipage}{\linewidth}
\begin{lstlisting}[style=myScalastyle,label=lst:akkahttp,caption={application.conf}]
akka.http {

  server {
    idle-timeout = infinite
  }
}
\end{lstlisting}
\end{minipage}

Currently the time-out for providing the information to the frontend is set to 24 hours in \textit{Main.scala}.

\section{Lazy Logging}
Previously logging only occurred in the console. This made debugging of long simulations difficult. Especially for the evaluation of any implementations a log file is necessary. For this reason the Scala modules \textit{logback} and \textit{scala-logging} were integrated into the project. Every important event is logged into \textit{/logfile.log}.

\section{Time between Blocks}
The time between the blocks or also called block time is a very important metric. It can be used to check the system health. Due to the nature of the algorithm, a new block can be immediately found after the last one or it can take longer than usual. This can lead to unusual behaviour, as nodes might not have enough time to send transactions, synchronise their transactions pools or the blockchain. Therefore the block time can also be used to explain unusual behaviour. For the implementation of the Time between Blocks Figure \ref{fig:timeBetweenBlocks} next to the event timestamps only the beginning of the Simulation was additional necessary to calculate the time of the first block.

\begin{figure}
\centering
\includegraphics[width=1\textwidth]{"figures/Testing/Time between Blocks".PNG}
\caption{Screenshot Time between Blocks
\label{fig:timeBetweenBlocks}}
\end{figure}

\section{Block size limit \label{subsection:blocksizelimit}}
One of the biggest unresolved issues of Bitcoin-like Blockchains is scalability. The main metric to measure scalability is transactions per seconds \textit{tps}. One drawback of this metric is that it contains no information about the transaction size or the usefullness of the transaction. Previously VIBES had no block size limit. This means infinite transactions can be processed and changing input parameters has no effect on the scalability. To be able to investigate the effects of different input parameters on the scalability, the introduction of a block size limit is necessary. This allows a more accurate simulation of Bitcoin. The block size limit is for example necessary to analyse the implications of Segwit2x according to VIBES \cite{vibes}.

The only prerequisites is to add one additional \textbf{configuration parameter} \textit{maxBlockSize}: the maximal block size in KB, the current default value is 1.000 KB.

The design and architecture changes of the backend mainly happen in the model VBlock. All generated blocks obey the block size limit depending on if the simulation is a Bitcoin-like Blockchain Simulation.

\begin{minipage}{\linewidth}
\begin{lstlisting}[style=myScalastyle,label=lst:blocksizelimit,caption={VBlock with focus on block size limit}]
object VBlock extends LazyLogging {
  def createWinnerBlock(node: VNode, timestamp: DateTime): VBlock = {
    var maxTransactionsPerBlock : Int = 0
    var processedTransactionsInBlock: Set[VTransaction] = Set.empty

    if (VConf.strategy == "BITCOIN_LIKE_BLOCKCHAIN") {
      maxTransactionsPerBlock = Math.floor(VConf.maxBlockSize / VConf.transactionSize).toInt    
      
      // takes the amount of maxTransactionsPerBlock out of the transaction pool into the winner block
      processedTransactionsInBlock = node.transactionPool.toSeq.take(maxTransactionsPerBlock).toSet
    } else {
      maxTransactionsPerBlock = node.transactionPool.size
      processedTransactionsInBlock = node.transactionPool
    }
    
    VBlock(
      id = UUID.randomUUID().toString,
      origin = node,
      transactions = processedTransactionsInBlock,
      level = node.blockchain.size,
      timestamp = timestamp,
      recipients = ListBuffer.empty,
      transactionPoolSize = node.transactionPool.size
    )
  }
}
\end{lstlisting}
\end{minipage}

The Listing \ref{lst:blocksizelimit} shows only the essential lines of code. First, the maximal transactions per block is calculated via the maximal block size and the transaction size. For simplicity the transaction size is constant, therefore this calculation is simple. Due to rounding down the actual block size can't be bigger than the limit. Finally the transaction are taken out of the transaction pool and later this variable is used in the creation of the winner block.

\section{SegWit \label{subsection:segwit}}

In Chapter \ref{subsection:blocksizelimit} the block size limit was implemented to make the simulation more accurate and similar to the actual Bitcoin Network. In this subsection one step further is taken. To accurately simulate the Bitcoin Network the block size limit needs to replaced by a block weight limit like the actual Bitcoin Network did with the soft fork SegWit on 24th August 2017.

For a very simple implementation of SegWit, one could maybe just introduce a boolean segWitEnabled and replace the already existing block size limit with a block weight limit and transaction size with transaction weight. Since the comparison between non-SegWit und SegWit figures could be a very interesting use-case, new \textbf{configuration parameters} are introduced instead.

\begin{itemize}
\item \textit{blockWeightLimit}: maximal block weight limit in weight unit
\item \textit{transactionWeight}: witness data per transaction in weight unit
\end{itemize}

For the simulation part of the backend a new condition is added to the VBlock object.

\begin{minipage}{\linewidth}
\begin{lstlisting}[style=myScalastyle,label=lst:blockweightlimit,caption={VBlock with focus on block weight limit}]
      if (VConf.maxBlockWeight != 0 && VConf.transactionWeight != 0) {
        // SegWit is enabled
        maxTransactionsPerBlock = Math.floor(VConf.maxBlockWeight / VConf.transactionWeight).toInt
      } else {
        // SegWit is disabled
        // multiplies by 1000 because maxBlockSize is in KB and transaction size is in B
        maxTransactionsPerBlock = Math.floor(VConf.maxBlockSize * 1000 / VConf.transactionSize).toInt
      }
\end{lstlisting}
\end{minipage}

Numbers for the SegWit vs Non-SegWit analysis are provided in the frontend. These are calculated in the ReducerActor as can be seen in Listing \ref{lst:blockweightlimitCalculations}. The SegWit theoretical block weight limit and the Non-SegWit maximal block size are given input values. The SegWit maximal block weight considers the transaction size and is more realistic than the theoretical block weight limit. Additionally both maximal transactions per block and transactions per second values show the differences between SegWit and Non-SegWit while the actual simulation values are also shown in Figure \ref{fig:TransactionSummary}.

\begin{minipage}{\linewidth}
\begin{lstlisting}[style=myScalastyle,label=lst:blockweightlimitCalculations,
caption={Calculations for the comparisons in the ReducerActor}]
// works only for constant transaction size and weight, otherwise an array is necessary
    var segWitMaxBlockWeight = 0 // nonSegWitMaxBlockSize = VConf.maxBlockSize
    var segWitMaxTransactionsPerBlock = 0
    var nonSegWitMaxTransactionsPerBlock = 2147483647
    var maxTransactionsPerBlock = 0
    var segWitMaxTPS: Double = 0
    var nonSegWitMaxTPS: Double = 0
    if (VConf.transactionSize != 0) {
      // multiplies by 1000 because maxBlockSize is in KB and transaction size is in B
      nonSegWitMaxTransactionsPerBlock = Math.floor(VConf.maxBlockSize * 1000 / VConf.transactionSize).toInt
      maxTransactionsPerBlock = nonSegWitMaxTransactionsPerBlock
      nonSegWitMaxTPS = nonSegWitMaxTransactionsPerBlock.toDouble / VConf.blockTime.toDouble
      nonSegWitMaxTPS = (math rint nonSegWitMaxTPS * 1000) / 1000
    }
    if (VConf.maxBlockWeight != 0 && VConf.transactionWeight != 0) {
      segWitMaxTransactionsPerBlock = Math.floor(VConf.maxBlockWeight / VConf.transactionWeight).toInt
      segWitMaxBlockWeight = segWitMaxTransactionsPerBlock * VConf.transactionSize
      maxTransactionsPerBlock = segWitMaxTransactionsPerBlock
      segWitMaxTPS = segWitMaxTransactionsPerBlock.toDouble / VConf.blockTime.toDouble
      segWitMaxTPS = (math rint segWitMaxTPS * 1000) / 1000
    }
\end{lstlisting}
\end{minipage}

\begin{figure}
\centering
\includegraphics[height=0.5\textwidth]{"figures/Testing/TransactionSummary".PNG}
\caption{Screenshot Transaction Summary\label{fig:TransactionSummary}}
\end{figure}

\section{Transaction per second}

Figure \ref{fig:TransactionSummary} also shows the average transaction per second. The \textit{tps} is also called throughput or transaction rate. The average \textit{tps} is - as the Listing \ref{lst:tps} shows - calculated over the duration of the whole simulation and then given to the frontend.

\begin{minipage}{\linewidth}
\begin{lstlisting}[style=myScalastyle,label=lst:tps,
caption={Calculations for the tps in the ReducerActor}]
    var actualTPS: Double = longestChainNumberTransactions.toDouble / secondsBetween(VConf.simulationStart, VConf.simulateUntil).getSeconds.toDouble
    actualTPS = (math rint actualTPS * 1000) / 1000
\end{lstlisting}
\end{minipage}

According to Bitcoin-NG the \textit{tps} of Bitcoin pre-SegWit was limited to only 1 to 3.5 \textit{tps} for typical transaction sizes due to the block size at 1 MB \cite{bitcoinNG}. For Bitcoin heavy transaction loads are an obstacle for a more widespread use \cite{gateway}. A payment processor like VISA handles 4,000 transaction per second on average and has been stress-tested in 2013 to handle 47,000 transactions per second. In comparison, Bitcoin can only handle 7 transactions per second, due to the fact that block sizes are restricted to have a maximum size of 1 MB.

\section{Processed and pending transactions per block}

After introducing a block size limit in Chapter \ref{subsection:blocksizelimit} and SegWit in Chapter \ref{subsection:segwit} for the evaluation of correctness about transactions in general it is necessary to know what actually happens in the blocks. This means visualizations about the pending transactions and processed transactions per block would be very insightful.

For the pending transactions per block Figure \ref{fig:pendingTransactions} changes in the models VBlock and VEventTypes and the ReducterActor were done. Every block has the transaction pool size minus the included amount of transaction at the time of the block creation as a new attribute.

\begin{figure}
\centering
\includegraphics[width=1\textwidth]{"figures/Testing/pendingTransactions".PNG}
\caption{Screenshot Pending Transactions per Block
\label{fig:pendingTransactions}}
\end{figure}

For the processed transactions per block Figure \ref{fig:processedTransactions} changes to the same classes and additionally Main were done. The new attribute processed transactions of a block describes the transactions which were included by the node. This is shown as the blue line, the red line shows the maximum possible transactions depending on if the block size limit or SegWit are enabled. If the block size limit and SegWit are disabled (equal to zero), then the transaction limit per block is unlimited and the red line isn't shown.

\begin{figure}
\centering
\includegraphics[width=1\textwidth]{"figures/Testing/processedTransactions".PNG}
\caption{Screenshot Processed Transactions Per Block
\label{fig:processedTransactions}}
\end{figure}

Both Figures \ref{fig:pendingTransactions} and \ref{fig:processedTransactions} show that the first block contains no pending and no processed transactions. The reason for this is that the nodes do not send transactions before the genesis block is mined. One reason for having an empty genesis block is the fact that no Bitcoin exists before the first block, so no transaction fees can be paid and no Bitcoin can be send. But also transactions with zero transactions fees and zero Bitcoin sent can be valid and included in blocks. These transactions would be considered transaction spam. The miners just have no incentive to include zero fee transactions. Bitcoin's genesis block contains one transaction \cite{genesis}. In the end, this question about having zero, one or lots of transactions in the genesis block seems to be a question of personal preference. One disadvantage of having zero or one transaction in the genesis block is that it distorts transactions metrics like \textit{tps} for a low number of blocks or transactions.

\section{Transaction incentives and confirmation status}

In Bitcoin there are two types of incentives for miners, block rewards and transaction incentives or also called transaction fees. Previously these mining incentives were not considered. To make a more realistic simulation transaction incentives are added to the simulation. This allows analysis for example for determining the necessary price to include a transaction in a block within a certain time. It can also be used in future work for example about mining pools. Since research questions about transaction incentives are closely linked to the confirmation status new data structures are needed to easily access information about the creation time and confirmation time of transactions.

New variables for the transaction incentives and confirmation status are added to the VTransaction model. 

\begin{itemize}
\item \textit{transactionFee}: transaction fee in Satoshi
\item \textit{confirmation}: confirmation status as a boolean
\item \textit{creationLevel}: block level when the transaction was created
\item \textit{confirmationLevel}: block level when the transaction was included in a block
\end{itemize}

Transactions are assigned a random integer between 0 and 124 as transaction fee in Satoshi. This is about the same range as in reality, but the distribution is different. The real distribution can change from one moment to the next and is difficult to model. When a transaction gets included into a block, its transaction status changes from \textit{false} to \textit{true}.

To show the results of this implementation two charts were created. For these charts a slightly higher transaction throughput than block transaction capacity was chosen to show, because this shows the interesting in which the miners can choose between including transactions with high or low transaction incentives into their block.

\begin{figure}
\centering
\includegraphics[width=1\textwidth]{"figures/Testing/TransactionIncentives1".PNG}
\caption{Screenshot Transaction Confirmation Status per Transaction Fee
\label{fig:TransactionIncentives1}}
\end{figure}

Figure \ref{fig:TransactionIncentives1} shows the transaction confirmation status per transaction fee. The abscissa shows the transaction fees from 0 to 124 in Satoshi, the ordinate shows the amount of transactions. The red area shows the unconfirmed and the green area shows the confirmed transactions. It can be clearly seen, that the red area is only really big from 0 to 7 Satoshi. This means most of the pending transactions are the ones with the lowest transaction incentives.

Even in the case of block size limit or SegWit maximal transactions per block smaller than transaction throughput the red area exists. The reason  is the nodes are sending transactions even after the last block was mined.

\begin{figure}
\centering
\includegraphics[width=1\textwidth]{"figures/Testing/TransactionIncentives2".PNG}
\caption{Screenshot Average Transaction Confirmation Time per Transaction Fee
\label{fig:TransactionIncentives2}}
\end{figure}

The next Figure \ref{fig:TransactionIncentives2} shows the average transaction confirmation time per transaction fee. The abscissa shows the transaction fee again, the ordinate shows the confirmation time in blocks. Both Figures are from the same simulation. Therefore we can see that the average confirmation time for transaction fees 0 to 3 is zero blocks. The reason for this is that there are no confirmed transactions in this range. Maybe this visualisation is not perfect, since it may lead to the conclusion that transactions with fees from 0 to 3 are instantly included in a block. But infinity blocks is hard to visualise and taking the first non zero confirmation time would also be misleading. The highest confirmation time is the point where the transactions barely get included into blocks. After this bottleneck all transactions get included in about the same time.

For the generation of both charts all created transactions are sent from the backend to the frontend. The frontend then summarizes the transactions per transaction fee, this could also be done by the backend. Sending all transactions ever created in a simulation to the frontend is probably a bottleneck for simulations with a very large number of transactions. The reason for this design decision is the flexibility to create or change charts to analyse different aspects of transactions. During development no issues were found. For simulations with a very large number of blocks parts of the previously created frontend would also be a bottleneck, since also every created block is sent to it.

VIBES offers the possibility to change the parameters sent to the frontend fast and easily. For simulations with a very large number of transactions and/ or a very large number of blocks the frontend could be changed or the sought after data can also be output via log file or console.

\section{Alternative history attack}
A 51\% attack is one of the most commonly discussed attacks on the Bitcoin protocol. It belongs to the group of alternative history attacks.  Due to the way it works see Chapter \ref{subsection:background:alternativhistoryattack} complex changes are required.

\subsection{Prerequisites\label{prerequisites}}

To simulate an alternative history attack additional \textbf{configuration parameters} are necessary. These parameters are used for the actual simulation of the attack, the calculation of the success probability of the attack and the maximum safe transaction value.

\begin{itemize}
\item \textit{isAlternativeHistoryAttack}: if an alternative history attack is simulated as a boolean
\item \textit{hashRate}: attacker's hashRate as a percentage of the total hashRate of the Bitcoin Network
\item \textit{confirmations}: the amount of confirmations the attacked merchants are waiting for to accept a transaction
\item \textit{attackDuration}: the attacker gives up after mining a certain amount of blocks and not succeeding or if it is not possible any more to surpass the level of the honest blockchain
\item \textit{discountOnStolenGoods}: discount of the stolen goods by the attacker, a value from 0 (= full discount) to 1 (= no discount)
\item \textit{amountOfAttackedMerchants}: the attack is carried out against a certain amount of merchants at the same time
\item \textit{blockReward}: current block reward in BTC
\end{itemize}

\subsection{Design and Architecture}

\subsubsection{Simulating the attack}

In the following the attacker's nodes, blockchain or blocks are interchangeably described as evil, private or malicious and the honest networks' nodes as good or public.

The solution for the simulation of an alternative history attack selects nodes as attacking nodes according to the attacker's hash rate as a percentage of the total Bitcoin Network.
The good and the evil nodes both can mine the genesis block. The genesis block is then the first block in both the good and the evil blockchain. For simplicity we assume that the attacker successfully sent the transactions to the attacked merchants in the second block of the honest blockchain. Immediately after the genesis block is mined, the evil nodes start mining together on their own evil blockchain. It is necessary for all nodes to update their neighbour nodes to only have their corresponding nodes as neighbours. The synchronising of the blockchain is only possible for the same type of node. As a counterexample the attacker's hash rate would suffer if the evil nodes could not synchronise their blocks properly if a high percentage of their neighbours are honest nodes.

Finally the success of the simulated attack is decided if the attacker's blockchain level can surpass the honest blockchain's block level after waiting for the Merchants confirmation and before the attack duration ends. The attack can succeed, fail or be undecided. For example if a huge percentage of the network is malicious, then the honest network is likely to need a long time to reach the needed block level for the Merchants confirmation.

In the case of success or failure the two networks need to merge back together by updating their neighbours, allowing the synchronising of all blocks and taking the winning blockchain.

\subsubsection{Calculating the success probability  \cite{doublespending}}

To be able to validate the results of the Bitcoin-like Blockchain Simulation with an Alternative History Attack a correct reference value for the success probability is required. Therefore the success probability of an Alternative History Attack needs to be calculated.

Before the formula to calculate the success probability of an alternative history attack is shown, the variables need to be explained.
$q$ is \textit{hashRate}, the attacker's percentage of the hash rate of the total network. $p$ is $1-q$ and the percentage of the honest network.

\begin{equation}
p + q = 1
\end{equation}

It is the goal to calculate the success probability $r$. If the attacker's hash rate $q$ is equal or bigger than $p$, then the success probability of the attacker is 100\%.
Due to the implementation the behaviour of the implementation can deviate from the 100\%. For example the variables \textit{attackDuration}, \textit{confirmations} or the simulation duration can have an impact.
If $q < p$, then the upper complex formula with binomial coefficients needs to be calculated.

\begin{equation}
    r = 
\begin{cases}
    1-\sum\limits_{m=0}^n \binom{m+n-1}{m}(p^nq^m-p^mq^n),& \text{if } q < p\\
    1,              & \text{if } q \geq p
\end{cases}
\end{equation}

The formula for $q < p$ is transformed for the implementation. This allows the usage of factorial functions instead of binomial coefficients.

One difference between this formula and the implementation is the attack duration. The formula is not limited by an attack duration, while the implementation has one. We assume the difference is negligible. The default value of the attack duration is 20 blocks. The probability of an attacker winning despite being behind 20 blocks is in most cases very small.

\begin{equation}\label{eq:successProbability}
    r = 
\begin{cases}
    1-\sum\limits_{m=0}^n \frac{(m+n-1)!}{m!\,(n-1)!}(p^nq^m-p^mq^n),& \text{if } q < p\\
    1,              & \text{if } q \geq p
\end{cases}
\end{equation}

\subsubsection{Calculating the maximal safe transaction value  \cite{doublespending}}


\eqref{eq:successProbability}

\begin{equation}
\dfrac{(1 - r) oB}{ k  (\alpha + r - 1)}
\end{equation}

\subsection{Implementation}

The implementation of double-spending is complex due to the need of splitting up the nodes and having two separate blockchains running at the same time and after the double-spending attack the nodes are merging back together to work on one blockchain.

\subsubsection{VConf}
The VConf implements the new parameters for the alternative history attack which are mentioned in the Prerequisites (Chapter \ref{prerequisites}).

\subsubsection{Main}
The simulation and also the attack starts in Main. Main checks if an alternative history attack happens and sets up the configuration. After the end of the simulation Main also sends the results back to the frontend.

\subsubsection{VNode}
The VNode Model needs a new parameter \textit{isMalicious} as Option[Boolean].

\subsubsection{NodeRepoActor}
In case of an attack NodeRepoActor creates/registers nodes with their corresponding type Option[Boolean] in the predefined ratio according to the attacker's hash rate. Malicious nodes are set to Some(true).

\subsubsection{DiscoveryActor}
The DiscoveryActor updates the neighbours according to the defined Neighbours Discovery Interval. In the case of an active attack the nodes are only allowed to receive neighbours of the same type (malicious/non-malicious).

\subsubsection{NodeActor}
The node with the smallest timestamp is allowed to add his block in the NodeActor. Here several conditions are checked to make sure only in valid cases the blocks are added. In the case of an attack also the status of the attack is determined in the \textit{addBlockIfAlternativeHistoryAttack} function.
In the case of an preRestart the configuration is reset.
NodeActor has new property \textit{isEvil}.

\subsubsection{VBlock}
Robustness increased by considering that in an attack the recipients of a block can be null.

\subsubsection{ReducerActor}
The ReducerActor calculates the maximal safe transaction value and the success probability of the alternative history attack. It also prepares the other values connected to the attack.

\subsubsection{VEventTypes}
VEventTypes provides the new figures to the Main.

The block tree and branch selection visualization of the frontend was inspired by the double-spending paper \cite{doublespending}. Figure \ref{fig:AttackerWins} shows a successful attack. In this case the attack was successful immediately after the public branch reached the Merchants confirmation requirement. The blocks of the winning branch are shown as black squares and the losing branch's blocks are white. The public branch is always on the left side, the attacker's branch in the middle and the right column shows the block level. For better visibility in case of the attack succeeding only the necessary valid blocks are shown.
todo: update graphic

\begin{figure}
\centering
\includegraphics[width=1\textwidth]{"figures/Testing/AttackerWins".PNG}
\caption{Screenshot Block Tree, Branch Selection and Attack Summary - Attacker wins
\label{fig:AttackerWins}}
\end{figure}

Figure \ref{fig:AttackerLoses} shows a failed attack. As can be seen, the attack failed due to the public branch reaching the end of the attack duration without the attacker's branch overtaking once.
todo: better graphic

\begin{figure}
\centering
\includegraphics[width=1\textwidth]{"figures/Testing/AttackerLoses".PNG}
\caption{Screenshot Block Tree, Branch Selection and Attack Summary - Attacker loses
\label{fig:AttackerLoses}}
\end{figure}

\section{Transaction Spam}
In July 2018 the Ethereum Network was effected by transaction spam or also called a flood attack. Such an "attacker" in principle trades their own money to increase the transaction costs for everyone. Only intended functionality and valid transactions is used. Even Vitalik Buterin tweeted about it \cite{tweet}. The tweet can be seen in Figure \ref{fig:transactionSpam}. This transaction spam is also possible in the Bitcoin Network. Interesting research questions arise about the costs, which an malicious actor has to pay to make the Bitcoin Network unusable or too uneconomical to use for certain use-cases. In economics this is called crowding out.

\begin{figure}
\centering
\includegraphics[height=0.3\textwidth]{"figures/tweet".PNG}
\caption{Screenshot Tweet from Vitalik Buterin about Transaction Spam
\label{fig:transactionSpam}}
\end{figure}

\section{Technology Choice / Backend}

\section{Frontend}

talk about tech stack

The React Google Charts package was used for all the charts \cite{reactgooglecharts}. During development some error messages appeared about \textit{loader.js}, which seem to be all fixed now \cite{reactgooglechartsissue1} \cite{reactgooglechartsissue2}.

One of the main focuses of this paper is the frontend. Previously not everything captured by VIBES was visualised. This paper added lots of interesting graphics like block tree and branch selection, block time, pending transactions, processed transactions, transaction status and transactions fees and also new figures about double-spending, transactions and orphans to the frontend. But there may still very interesting information that has not yet been analysed or visualized. These graphics and figures were chosen to validate the correctness of the changes to the backend and can also be used for research questions about double-spending, transaction fees, transaction status, tps etc.

\begin{figure}
\centering
\includegraphics[width=1\textwidth]{"figures/configuration".PNG}
\caption{Screenshot Configuration
\label{fig:configuration}}
\end{figure}

\begin{figure}
\centering
\includegraphics[width=1\textwidth]{"figures/simulation".PNG}
\caption{Screenshot Simulation
\label{fig:simulation}}
\end{figure}

minor other stuff:
Masteractor: asserts
VBlock: assert error messages
check if simulation in past