\chapter{Approach}\label{chapter:approach}
In this chapter the changes to the existing VIBES framework are presented one by one. First the reasons for each improvement are described. Then the prerequisites for every change and the design and architecture are shown. Finally the implementation is explained. Part of the implementation is the implementation of the front-end. The front-end shows the results of the back-end and can therefore also be used for the evaluation.

\section{Bitcoin-like Blockchain Simulation}
changes necessary to differentiate strategies

\section{Lazy Logging}
Previously logging only occurred in the console. This made debugging for long simulations difficult. Especially for the evaluation of any implementations a log file is necessary. For this reason the Scala modules \textit{logback} and \textit{scala-logging} were integrated into the project. Every important event is logged into \textit{/logfile.log}.

\section{Block size limit}
One of the biggest unresolved issues of Bitcoin-like Blockchains is scalability. The main factor to measure scalability is transactions per seconds (tps). Previously VIBES had no block size limit. This means infinite transactions can be processed and changing input parameters has no effect on the scalability. To be able to investigate the effects of different input parameters on the scalability, the introduction of a block size limit is necessary. This allows a more accurate simulation of Bitcoin.

\subsection{Prerequisites}
\textbf{configuration parameters}

\begin{itemize}
\item \textit{maxBlockSize}: the max block size in KB, the current default value is 1.000 KB
\end{itemize}

\subsection{Design and Architecture}
The main back-end change happens in the model VBlock. Depending if the simulation is a Bitcoin-like Blockchain Simulation all generated blocks obey the block size limit. 

\subsection{Implementation}

\begin{minipage}{\linewidth}
\begin{lstlisting}[style=myScalastyle]
object VBlock extends LazyLogging {
  def createWinnerBlock(node: VNode, timestamp: DateTime): VBlock = {
    var maxTransactionsPerBlock : Int = 0
    var processedTransactionsInBlock: Set[VTransaction] = Set.empty

    if (VConf.strategy == "BITCOIN_LIKE_BLOCKCHAIN") {
      // todo think about if to implement SegWit (maxBlockWeight vs maxBlockSize)
      maxTransactionsPerBlock = Math.floor(VConf.maxBlockSize / VConf.transactionSize).toInt

      // sorts the transaction pool by the transaction fee
      processedTransactionsInBlock = node.transactionPool.toSeq.sortWith(_.transactionFee > _.transactionFee).take(maxTransactionsPerBlock).toSet

      // sets confirmation status of transaction true
      processedTransactionsInBlock.foreach { _.confirmation = true }

      // sets confirmation level of transaction
      processedTransactionsInBlock.foreach { _.confirmationLevel = node.blockchain.size }
    } else {
      maxTransactionsPerBlock = node.transactionPool.size
      processedTransactionsInBlock = node.transactionPool
    }

    VBlock(
      id = UUID.randomUUID().toString,
      origin = node,
      transactions = processedTransactionsInBlock,
      level = node.blockchain.size,
      timestamp = timestamp,
      recipients = ListBuffer.empty,
      transactionPoolSize = node.transactionPool.size
    )
  }
}
\end{lstlisting}
\end{minipage}

\section{Transaction fees}

\section{Block time}

\section{Alternative history attack}

\subsection{Prerequisites}

To simulate an alternative history attack additional \textbf{configuration parameters} are necessary. These parameters are used for the actual simulation of the attack, the calculation of the success probability of the attack and the maximum safe transaction value.

\begin{itemize}
\item \textit{isAlternativeHistoryAttack}: if an alternative history attack is simulated as a boolean
\item \textit{hashrate}: attacker's hashrate as a percentage of the total hashrate of the Bitcoin Network
\item \textit{confirmations}: the amount of confirmations the attacked merchants are waiting for to accept a transaction
\item \textit{attackDuration}: the attacker gives up after mining a certain amount of blocks and not succeeding or if it is not possible any more to surpass the level of the honest blockchain
\item \textit{discountOnStolenGoods}: discount of the stolen goods by the attacker, a value from 0 (= full discount) to 1 (= no discount)
\item \textit{amountOfAttackedMerchants}: the attack is carried out against a certain amount of merchants at the same time
\item \textit{blockReward}: current block reward in BTC
\end{itemize}

\subsection{Design and Architecture}

\subsubsection{Simulating the attack}

In the following the attacker's nodes, blockchain or blocks are interchangeably described as \textit{evil} and the honest networks' nodes as \textit{good}.\linebreak

The solution for the simulation of an alternative history attack selects nodes as attacking nodes according to the attacker's hashrate as a percentage of the total Bitcoin Network.
The good and the evil nodes both can mine the genesis block. The genesis block is then the first block in both the good and the evil blockchain. For simplicity we assume that the attacker successfully sent the transactions to the attacked merchants in the second block of the honest blockchain. Immediately after the genesis block is mined, the evil nodes start mining together on their own evil blockchain. It is necessary for all nodes to update their neighbour nodes to only have their corresponding nodes as neighbours. For example in the case of a low amount of evil nodes and a low amount of neighbours... Since the attacker of course doesn't want his...\linebreak

Finally the success of the simulated attack is decided if the attacker's blockchain level can surpass the honest's blockchain level after waiting for the Merchants confirmation and before the attack duration ends.

\subsubsection{Calculating the success probability  \cite{doublespending}}

The ... is ...
Before the formula to calculate the success probability of an alternative history attack is shown, the variables need to be explained.\linebreak
$q$ is \textit{hashRate}, the attacker's percentage of the hash rate of the total network. $p$ is $1-q$ and the percentage of the honest network.

\begin{equation}
p + q = 1
\end{equation}

It is the goal to calculate the success probability $r$. If the attacker's hash rate $q$ is equal or bigger than $p$, then the success probability of the attacker is 100\%.\newline
Due to the implementation the behaviour of the implementation can deviate from the 100\%. For example the variables \textit{attackDuration}, \textit{confirmations} or the simulation duration can have an impact.\newline
If $q < p$, then the upper complex formula with binomial coefficients needs to be calculated.

\begin{equation}
    r = 
\begin{cases}
    1-\sum\limits_{m=0}^n \binom{m+n-1}{m}(p^nq^m-p^mq^n),& \text{if } q < p\\
    1,              & \text{if } q \geq p
\end{cases}
\end{equation}

The formula for $q < p$ is transformed for the implementation. This allows the usage of factorial functions instead of binomial coefficients.

\begin{equation}\label{eq:successProbability}
    r = 
\begin{cases}
    1-\sum\limits_{m=0}^n \frac{(m+n-1)!}{m!\,(n-1)!}(p^nq^m-p^mq^n),& \text{if } q < p\\
    1,              & \text{if } q \geq p
\end{cases}
\end{equation}

\subsubsection{Calculating the maximal safe transaction value  \cite{doublespending}}

\eqref{eq:successProbability}

\begin{equation}
\dfrac{(1 - r) oB}{ k  (\alpha + r - 1)}
\end{equation}

\subsection{Implementation}